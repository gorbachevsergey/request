// командой getElementById получаем ссылка на эелмент, которая дает нам возможность на изменения свойств элемента
// почитай, что ты присваиваешь
const button = document.getElementById('btnLoad'); // присваем переменной id элемента
let text = document.getElementById('textLoad')

// Обработчик событий
// "слушатель" наверное правильнее слово, как называется эта функция?
button.addEventListener('click', function () { // добавляем прослушку на кнопку, при активации кнопки запуститься функция
  // да в старом варрианте именно так. исправил, теперь при формирование списка мы также добаляем определенный клас и данным способом его будем удалять
  // а если у тебя на странице будет еще список? ты его тоже потрешь?
    $('.textLoad').remove(); // удаляем все элементы списка
  let xhr = new XMLHttpRequest(); // Создаем XMLHttpRequest для выполнения запроса
  xhr.open(   // инициализируем запрос
    'get', // типа запроса
    'https://60d2c48c858b410017b2e2d9.mockapi.io/users', // адресс сервера
    true, // логичиеское выражение определает должен ли запрос быть асинхронным
  );
  xhr.send(); // устанавливаем соединение и отсылаем запрос к серверу
  xhr.onreadystatechange = function () { //срабатывает обработчик событий в результате чего вызывается функция
    try {
      if (xhr.readyState != 4) { // проверяем что xhr полностью завершена, если нет то делаем return
        return;
      }
      // нет,т.к. вызывается после успешного кода, переписал код для для обработок ошибок
      // а если у тебя запрос ответит не кодом 200 ты обработаешь ошибку?
      if (xhr.status === 200) {// проверяем статус, 200 означает успешный запрос

        let result = JSON.parse(xhr.response); // сохраняем в перменную данные полученные в результате ответа
        for (let i = 0; i < result.length; i++) {
          // .innerHTML = xhr.responseText - а это что делает?
          //зачем innerHTML я вставил я хз, innerHTML нужен для получения доступа как к чтению так и изменению, мы можем получать и изменять содержимое элемента, к пустому элементу обратится нельзя будет
          //xhr.responseText тоже хз, даже свою логмигу понять не могу. видимо мозг кипел и что то вставил, а так xhr.responseText - тут мы запрашиваем ответ ввиде текста если он есть, если нет то будет null
          $('ul:first').after('<li class="textLoad">' + result[i]['name'] + '</li>')// запускаем функцию цель которой перебать все данный в переменной result и добавить их в список на html страницу
        }

      } //ловим ошибку если вдруг ошибилсь в переменных в данном случае
    } catch (e) {
      alert('Ошибка: ' + e.message)
    }
  }



});
